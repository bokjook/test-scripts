### Author:   Johnathan Wong



import Configuration.configparser
from pprint import pprint
import json
import Library
import time
import Library.logger
import Library.start_esx_vms
import Library.map_dataluns
import sys

Logger = Library.logger.Logger
logfile = Configuration.configparser.logfile

def io_stress(ucs_info_filename):
    """
    This function perform IO on the servers with DT.
    :param ucs_info_filename:
    :return:
    """
    Logger.info("ucs_info_filename from io_stress function is:%s"%ucs_info_filename)

    Logger.info ("Reading the ucs info file now, from io_stress function")
    with open (ucs_info_filename) as ucs_info_handle:
        ucs_info_dic = json.load(ucs_info_handle)
        Logger.info("Printing the ucs_info_dic after reading from ucs_info.json")
    with open(Configuration.configparser.logfile,'a') as file_handle:
        pprint(ucs_info_dic,file_handle)
    if ucs_info_dic == {}:
        Logger.critical("UCS INFO is empty terminating the test run")
        sys.exit(0)
    if "storage" in Configuration.configparser.os_compat_type:
        Logger.info("Enabling all the data luns vhbs's and rebooting the servers to find all the data luns ")
        flag = Library.map_dataluns.mapdataluns(ucs_info_filename)
        Logger.info("flag is %s"%flag)
    oses_list = []
    ip_list = []
    for line in ucs_info_dic.values():
        Logger.info ("Creating the ip address list and corresponding OS flavor list ")
        serverips = line.split(';')[1]
        Logger.info("server ip's are :%s"%serverips)
        serverip_list = serverips.split(',')
        Logger.info("server ip's are :%s",serverip_list)
        os_version = line.split(';')[4]
        Logger.info("os_version on split is : %s"%os_version)
        if "WIN" in os_version:
            username = Configuration.configparser.win_username
            password = Configuration.configparser.win_password
        else:
            username = Configuration.configparser.username
            password = Configuration.configparser.password
        for ip in serverip_list:
            serverip = Library.ssh_host.ssh_connect(ip,username,password)
            if serverip:
                ip_list.append(serverip)
                oses_version = line.split(';')[4]
                oses_list.append(oses_version)
                break
    Logger.info("server ip list for io-stress is:%s",ip_list)
    Logger.info("os_version list for io-stress is:%s",oses_list)

    #copy VMs for ESX hosts
    flag = Library.start_esx_vms.vm_on_host(ip_list, oses_list)
    Logger.info("flag is %s"%flag)
    vm_dic = {}
    for ip,oses in zip(ip_list,oses_list):
        if "ESX" in oses:
            #Get vm ip
            Logger.info("About to get VM IPs")
            vmip_flag = Library.start_esx_vms.get_vm_ip(ip)
            Logger.info ("vm ip of server %s is %s"%(ip,vmip_flag))
            if vmip_flag:
                vm_dic[ip] = vmip_flag
    Logger.info ("\n Printing vm_dic dictionary containing the vmip of each server")
    with open(Configuration.configparser.logfile,'a') as file_handle:
        pprint(vm_dic,file_handle)
    #Copy DT to servers/VMs
    flag = Library.start_esx_vms.copy_dt(ip_list,oses_list)
    Logger.info("flag is %s"%flag)
    # Run DT with parameters from configuration file
    for ip,oses in zip(ip_list,oses_list):
        Logger.info ("About to start IO in server :%s"%ip)
        outfile = Configuration.configparser.outfile
        limit = Configuration.configparser.limit
        procs = Configuration.configparser.processes
        error_limit = Configuration.configparser.error
        runtime = Configuration.configparser.io_stress_time
        prefix = "%d@%h"
        keepalive = "300SecKeepAliveMsg##%h@%d##PassCount:%p##IOMode:%i##TotalTestTime:" \
            "%T##PassTestTime:%t##BlocksTransferred:%l##RecordsRead:%r##RecordsWritten:" \
            "%w##KBsPerSecond:%kbps##IOsPerSecond:%iops"
        dt_string = "cd /var/tmp;chmod 777 *;rm -rf test-*;cat /dev/null > dtlog ; /var/tmp/dt-linux of=%s limit=%s procs=%s errors=%s notime=fsync," \
                "close oflags=trunc  incr=var min=2k max=64k dispose=keep pattern=iot " \
                "prefix=%s iotype=random keepalivet=300 " \
                "keepalive=%s " \
                "enable=syslog,noprog,microdelay disable=pstats flags=direct noprogt=15s noprogtt=900s " \
                "history=3 hdsize=128 alarm=3s rdelay=5000 wdelay=5000 runtime=%s log=/var/tmp/dtlog & "\
                                    %(outfile,limit,procs,error_limit,prefix,keepalive,runtime)
        if "WIN" in oses:
            username = Configuration.configparser.win_username
            password = Configuration.configparser.win_password
            Logger.info("Starting IO on the server :%s"%ip)
            Logger.info("The following order LIMIT:PROCS:IOTYPE:RUNTIME:ERROR")
            dt_string = "c:\\UCSTools\\Operate.ps1 RunIO Stress %s:%s:%s:%s:%s"%(limit,procs,"random",runtime,error_limit)
            cmd_output = Library.ssh_host.ssh_execute_cmd(ip,dt_string,username,password)
            Logger.info("Executed Command: %s" %cmd_output)
            Logger.info("DT string is :%s"%dt_string)
        elif "ESX" in oses:
            if ip in vm_dic.keys():
                vmip = vm_dic[ip]
                Logger.info("Starting IO on server:%s on the VM :%s"%(ip,vmip))
                flag = Library.ssh_host.ssh_execute_cmd(vmip,dt_string)
                Logger.info("flag is %s"%flag)
            else:
                Logger.error("No VMIP found for ip:%s"%ip)
                assert " NO VMIP found to start IO"
        else:
            Logger.info("Starting IO for Linux flavors")
            flag = Library.ssh_host.ssh_execute_cmd(ip,dt_string)
            Logger.info("flag is %s"%flag)
    if ip_list:
        Logger.info("Waiting %s seconds for IO to complete."%Configuration.configparser.io_stress_time)
        time.sleep(float(Configuration.configparser.io_stress_time))
        Logger.info("Sleeping extra 130 sec for I/O to settle.")
        time.sleep(130)
    Logger.info("IO Stress completed on servers")
